<!DOCTYPE html>
<html lang=" en-US ">

<head>
	<meta charset='utf-8'>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="/assets/css/style.css?v=78c8719698feee0553096165409216db0a43f06f">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">

	<style>
		.navbar {
			overflow: hidden;
		}

		.navbar a {
			float: left;
			font-size: 16px;
			color: white;
			padding: 2px 15px;
			text-align: center;
			text-decoration: none;
		}

		.dropdown {
			float: left;
			overflow: hidden;
		}

		.dropdown .dropbtn {
			font-size: 16px;
			border: none;
			outline: none;
			color: white;
			padding: 2px 15px;
			background-color: inherit;
			font-family: inherit;
			margin: 0;
		}

		.navbar a:hover,
		.dropdown:hover .dropbtn {
			background-color: green;
		}

		.dropdown-content {
			display: none;
			position: absolute;
			background-color: #202020;
			min-width: 150px;
			box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
			z-index: 1;
		}

		.dropdown-content a {
			float: none;
			color: white;
			padding: 8px 14px;
			text-decoration: none;
			display: block;
			text-align: left;
		}

		.dropdown-content a:hover {
			background-color: #4666FF;
		}

		.dropdown:hover .dropdown-content {
			display: block;
		}
	</style>

	<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Migrating to NixOS | datdhruvjain.github.io</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Migrating to NixOS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Interesting learnings on Computer stuff." />
<meta property="og:description" content="Interesting learnings on Computer stuff." />
<link rel="canonical" href="http://192.168.1.117:4000/tools/Nix/GoodExplainNix.html" />
<meta property="og:url" content="http://192.168.1.117:4000/tools/Nix/GoodExplainNix.html" />
<meta property="og:site_name" content="datdhruvjain.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-14T04:00:00+04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Migrating to NixOS" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://192.168.1.117:4000/tools/Nix/GoodExplainNix.html"},"@type":"BlogPosting","url":"http://192.168.1.117:4000/tools/Nix/GoodExplainNix.html","headline":"Migrating to NixOS","dateModified":"2019-03-14T04:00:00+04:00","datePublished":"2019-03-14T04:00:00+04:00","description":"Interesting learnings on Computer stuff.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>

	<header>
		<div class="container">
			<a id="a-title" href="/">
				<h1>datdhruvjain.github.io</h1>
			</a>
			<h2>Interesting learnings on Computer stuff.</h2>

			<!--- need to check what this is all about
		<section id="downloads">
		
		</section>
		--->

			<section class="navbar">


				<!-- THE NON-DROPDOWN MENUS WORK LIKE THIS
				----------------------------------------
				
				<a href="https://datdhruvjain.github.io/directory/file">Title 1</a>
				<a href="./relative-file">Title 2</a>
				<a href="../dir/relative-file-path">Title 3</a>
				<a href="https://datdhruvjain.github.io/blockchain/blockchain">Blockchain</a>

				#	Do Not add add the extention to the file, eg do not put file.md, just file
				---------------------------------------->

				<!-- THE DROPDOWN MENUS WORK LIKE THIS
				----------------------------------------
				
				<div class="dropdown">
					<button class="dropbtn">dropdown-title
						<i class="fa fa-caret-down"></i>
					</button>
					<div class="dropdown-content">
						<a href="https://datdhruvjain.github.io/directory/file">Title 1</a>
						<a href="./relative-file">Title 2</a>
						<a href="../dir/relative-file-path">Title 3</a>
					</div>
				</div>

				#	Do Not add add the extention to the file, eg do not put file.md, just file
				------------------------------------------>

				<a href="/configurations/configurations">My Configs</a>


				<div class="dropdown">
					<button class="dropbtn">Journeys
						<i class="fa fa-caret-down"></i>
					</button>
					<div class="dropdown-content">
						<!--a href="https://datdhruvjain.github.io/journeys/blockchain/blockchain">Blockchain</a-->
						<a href="/journeys/cybersec/cybersec">Cyber Sec</a>
						<a href="/journeys/thm/thm">TryHackMe Journeys</a>
					</div>
				</div>

				<div class="dropdown">
					<button class="dropbtn">Prog Langs
						<i class="fa fa-caret-down"></i>
					</button>
					<div class="dropdown-content">
						<a href="/prog_langs/python/python">Python</a>
						<a href="/prog_langs/cpp/cpp">C++</a>
					</div>
				</div>

				<div class="dropdown">
					<button class="dropbtn">Tools
						<i class="fa fa-caret-down"></i>
					</button>
					<div class="dropdown-content">
						<a href="/tools/git">Git</a>
						<a href="/tools/vim/vim-learnings">Vim</a>
						<a href="/tools/markdown">Markdown</a>
						<a href="/tools/computer-networks/computer-networks">Computer-Networks</a>
					</div>
				</div>


				<!-- add new items from here -->
			</section>

		</div>
	</header>

	<div class="container">
		<section id="main_content">
			<small>14 March 2019</small>
<h1>Migrating to NixOS</h1>

<p class="view">by </p>

<p>After running <a href="https://www.archlinux.org/">Arch Linux</a> for the last decade, I’ve finally made
the jump to <a href="https://nixos.org/">NixOS</a>. For me, this means updating two VMs
(VirtualBox and VMWare) and a bare-metal install (an aging MacBook
Air).</p>

<p>I’ve repurposed my old <a href="https://github.com/malloc47/config">config repo</a> to store both my dotfiles as
 well as the NixOS <code class="language-plaintext highlighter-rouge">configuration.nix</code> files.</p>

<p>Since I was already making a big transition, I decided to take the
opportunity to retool a few more things in my dev setup:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Old</th>
      <th>New</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OS</td>
      <td>Arch Linux</td>
      <td>NixOS</td>
    </tr>
    <tr>
      <td>Shell</td>
      <td>Bash</td>
      <td>Zsh</td>
    </tr>
    <tr>
      <td>Terminal</td>
      <td>urxvt</td>
      <td>Alacritty</td>
    </tr>
    <tr>
      <td>Multiplexer</td>
      <td>screen</td>
      <td>tmux</td>
    </tr>
    <tr>
      <td>Window Manager</td>
      <td>XMonad</td>
      <td>i3</td>
    </tr>
    <tr>
      <td>Editor</td>
      <td>Emacs</td>
      <td>Emacs</td>
    </tr>
  </tbody>
</table>

<p>I initially wanted to make the jump from X11 to Wayland, but NixOS
<a href="https://github.com/NixOS/nixpkgs/projects/11">isn’t quite ready</a> just yet.</p>

<p>My goal for this writeup is to document the rationale for making the
switch, capture the stuff I wish I had known before diving into the
Nix language, and describe the particulars of how I organize my new
setup.</p>

<h1 id="motivation">Motivation</h1>

<p>While I lack a single compelling reason to make the jump, there are a
few pain points with my Arch setup that, together, pushed me to give
NixOS a shot:</p>

<ul>
  <li>
    <p><strong>Falling behind on Arch changes.</strong> While I benefited a few times
from Arch’s rolling update process, in practice I’ve rarely found it
was something I needed. Not staying on top of Arch updates
invariably leads to painful upgrades that take time to work
through. Taking snapshots of my VMs reduced a lot of this upgrade
risk, but it takes more time than I’m willing to spend to upgrade my
bare-metal Arch install after neglecting it for extended periods.</p>
  </li>
  <li>
    <p><strong>Package drift among machines.</strong> Having my VMs get slightly
different versions of packages from my Linux laptop, or forgetting
to install the same set of packages across all machines was a minor
but consistent annoyance. I kept a list of arch packages that I’d
move from machine to machine, but nothing forced me to audit that
the installed packages matched the list.</p>
  </li>
  <li>
    <p><strong>Limited local install options.</strong> I’ve grown reliant on Docker for
infrastructural components (e.g. Postgres), but being able to
install specific dev tools on a per-project basis (I’ve been playing
with <a href="https://www.qgis.org/">QGIS</a> recently) is something I’ve constantly found
painful, the few times I’ve bothered at all.</p>
  </li>
</ul>

<h1 id="nix">Nix</h1>

<p>The big ideas behind the Nix ecosystem are covered in <a href="https://nixos.org/nix/">detail
elsewhere</a>; what was appealing to me in particular was Nix’s
emphasis on reproducibility, file-driven configuration, and functional
approach to its package repository, nixpkgs. You can think of the Nix
package manager as a hybrid of <code class="language-plaintext highlighter-rouge">apt-get</code> and Python’s <code class="language-plaintext highlighter-rouge">virtualenv</code>
with a sprinkling of <code class="language-plaintext highlighter-rouge">git</code>; you can use Nix to build multiple,
isolated sets of packages on, say, a per-project basis, with the
guarantee that Nix only needs to fetch (or build) shared dependencies
once. Nix stores all built packages in the Nix store which serves as a
local cache. Nix grafts together a collection of Linux directories
(<code class="language-plaintext highlighter-rouge">bin</code>, <code class="language-plaintext highlighter-rouge">usr</code>, etc.) by symlinking the appropriate files contained in
the packages that live in the Nix store. This isolated environment can
be system-wide (in the case of NixOS), local to your user (<code class="language-plaintext highlighter-rouge">nix-env</code>)
or tailed for a specific project (<code class="language-plaintext highlighter-rouge">nix-shell</code>).</p>

<p><code class="language-plaintext highlighter-rouge">nix-shell</code> serves a few different roles in the Nix ecosystem, but one
of those roles is to make dependencies defined in a “derivation”
(Nix’s version of a makefile) available for use in a shell. These
derivations are used to define a hermetically-sealed environment for
building a package as well as collecting the commands to configure and
run a build. We can re-use just the environment-prep part of a
derivation along with <code class="language-plaintext highlighter-rouge">nix-shell</code> to drop us into a terminal that has
exactly the packages we want. Here’s an example of a derivation for a
TeX project:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">with</span> <span class="kr">import</span> <span class="o">&lt;</span><span class="nv">nixpkgs</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="nv">stdenv</span><span class="o">.</span><span class="nv">mkDerivation</span> <span class="p">{</span>
  <span class="nv">name</span> <span class="o">=</span> <span class="s2">"my-document"</span><span class="p">;</span>
  <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
    <span class="nv">texlive</span><span class="o">.</span><span class="nv">combined</span><span class="o">.</span><span class="nv">scheme-full</span>
  <span class="p">];</span>
  <span class="nv">shellHook</span> <span class="o">=</span> <span class="s2">"pdflatex document.tex"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this derivation placed in <code class="language-plaintext highlighter-rouge">shell.nix</code>, running a <code class="language-plaintext highlighter-rouge">nix-shell</code> in
the same directory will fetch the entirety of TeX Live (which is <a href="https://tex.stackexchange.com/questions/302676/how-large-is-the-full-install-of-texlive/323739">not
small</a>)
and make all the related files, configuration, tools, fonts, commands,
etc. available in the shell. It then uses one of these tools
(<code class="language-plaintext highlighter-rouge">pdflatex</code>) to run the “build” of <code class="language-plaintext highlighter-rouge">document.tex</code> to generate a
PDF. Writing a full derivation file isn’t necessary if you don’t need
to be dropped into a shell for further work. The following is
equivalent to the derivation above, but does not keep TeX Live
available in the shell after it is done building the document:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">nix</span> <span class="nv">run</span> <span class="nv">nixpkgs</span><span class="o">.</span><span class="nv">texlive</span><span class="o">.</span><span class="nv">combined</span><span class="o">.</span><span class="nv">scheme-full</span> <span class="o">-</span><span class="nv">c</span> <span class="nv">pdflatex</span> <span class="nv">document</span><span class="o">.</span><span class="nv">tex</span>
</code></pre></div></div>

<p>I only rarely need TeX, so being able to make TeX available on a
per-project basis without having all its commands pollute my <code class="language-plaintext highlighter-rouge">PATH</code>
when doing non-TeX work is useful. Going further, I can mix-and-match
versions of Python, the JVM, Postgres, etc. independently for each
project I have without having to use <code class="language-plaintext highlighter-rouge">sudo</code>.</p>

<h1 id="nixpkgs">nixpkgs</h1>

<p>While the Nix Expression Language is somewhat esoteric, the big ideas
aren’t far removed from features in mainstream functional
languages. nixpkgs in particular can be conceptualized as a single
large map (called an Attribute Set or attrset in Nix) from keys to
derivations:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="c"># &lt;snip&gt;</span>
  <span class="nv">tmux</span> <span class="o">=</span> <span class="nv">callPackage</span> <span class="sx">../tools/misc/tmux</span> <span class="p">{</span> <span class="p">};</span>
  <span class="c"># &lt;snip&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see a meaty example of nixpkg’s package list <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/all-packages.nix">here</a>. This
would normally be an unwieldy thing to build in memory on every
interaction with the package manager, however Nix lazily loads the
contents of this attrset. Nix even provides the option to make these
attribute sets “recursive” allowing the values to reference sibling
keys, e.g.</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">rec</span> <span class="p">{</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nv">b</span> <span class="o">=</span> <span class="nv">a</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>nixpkgs provides <a href="https://nixos.org/nixos/nix-pills/nixpkgs-overriding-packages.html">facilities</a> to change or update existing
packages with custom configuration, and add new entries to the package
attrset. It does this by way of “overlays” which are a <a href="http://r6.ca/blog/20140422T142911Z.html">fixed
point</a> over the package attrset. Nix’s approach of effectively
rebuilding a facsimile of the <a href="http://www.pathname.com/fhs/">FHS</a> on every run means that
“manual” intervention to install things outside of a package manager
(say, copying a <code class="language-plaintext highlighter-rouge">ttf</code> font into <code class="language-plaintext highlighter-rouge">/usr/share/fonts</code>) is not feasible,
so having an easy way to fold your own set of custom packages into the
package attrset is vital.</p>

<p>The other important aspect to nixpkgs is that it is versioned in git
(conveniently alongside NixOS in the same repo). The Nix CLI tools can
fetch and install the latest set of packages by rolling the local
clone of nixpkgs forward and then rebuilding your packages. Such a
rebuild can apply to all the packages on your entire system, or just a
particular derivation’s local packages. This can work the other
direction as well: If you prefer your package set to remain completely
fixed, you can pin the nixpkgs clone to a particular git SHA. Stable
releases of NixOS are handled as branches of the nixpkgs repo, which
do get critical updates but avoid all the bleeding-edge changes that
the <code class="language-plaintext highlighter-rouge">master</code> branch has.</p>

<h1 id="nixos">NixOS</h1>

<p>NixOS goes a step further and utilizes attrsets to configure the OS
itself. Not unlike application configuration (for which there
<a href="https://github.com/lightbend/config">are</a>
<a href="https://github.com/markbates/configatron">numerous</a>
<a href="https://github.com/weavejester/environ">libraries</a>), NixOS defines
your OS in a series of one or more attrsets that are merged together;
unlike traditional configuration approaches that use a
last-merged-wins strategy, however, NixOS’s <a href="https://nixos.wiki/wiki/NixOS:Properties">properties</a> provide
per-field control over the priority of merges along with conditionals
that control whether an option is merged or not.</p>

<p>This approach to OS configuration is useful for defining options
amongst a set of similar but not identical OSs. For my NixOS config,
I’ve created a base <a href="https://github.com/malloc47/config/blob/cd6d1568f50c9b839f5146b45362cd6c4d857882/nixos/configuration.nix"><code class="language-plaintext highlighter-rouge">configuration.nix</code></a> file that contains common
options that I want set across all my machines (abbreviated example
here):</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="nv">config</span><span class="p">,</span> <span class="nv">pkgs</span><span class="p">,</span> <span class="o">...</span> <span class="p">}:</span>
<span class="p">{</span>
  <span class="nv">time</span><span class="o">.</span><span class="nv">timeZone</span> <span class="o">=</span> <span class="s2">"America/Chicago"</span><span class="p">;</span>
  <span class="nv">environment</span><span class="o">.</span><span class="nv">systemPackages</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span><span class="nv">feh</span> <span class="nv">vim</span> <span class="nv">wget</span><span class="p">];</span>
  <span class="nv">programs</span><span class="o">.</span><span class="nv">zsh</span><span class="o">.</span><span class="nv">enable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nv">users</span><span class="o">.</span><span class="nv">users</span><span class="o">.</span><span class="nv">johndoe</span><span class="o">.</span><span class="nv">shell</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">zsh</span><span class="p">;</span>
  <span class="c"># &lt;snip&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I then import this common file into host-specific files that each
contain options specific to that particular machine, e.g. a VM host:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="nv">config</span><span class="p">,</span> <span class="nv">pkgs</span><span class="p">,</span> <span class="o">...</span> <span class="p">}:</span>
<span class="p">{</span>
  <span class="nv">imports</span> <span class="o">=</span> <span class="p">[</span> <span class="sx">./configuration.nix</span> <span class="p">];</span>
  <span class="nv">services</span><span class="o">.</span><span class="nv">vmwareGuest</span><span class="o">.</span><span class="nv">enable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nv">users</span><span class="o">.</span><span class="nv">users</span><span class="o">.</span><span class="nv">johndoe</span><span class="o">.</span><span class="nv">shell</span> <span class="o">=</span> <span class="nv">mkOptionDefault</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">bash</span><span class="p">;</span>
  <span class="c"># &lt;snip&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the <code class="language-plaintext highlighter-rouge">mkOptionDefault</code> function that reduces the priority of the
<code class="language-plaintext highlighter-rouge">pkgs.bash</code> value from the default of 100 to 1500. Had I left off
<code class="language-plaintext highlighter-rouge">mkOptionDefault</code>, NixOS would complain that <code class="language-plaintext highlighter-rouge">johndoe.shell</code> was
declared twice. However, by reducing its priority, the
<code class="language-plaintext highlighter-rouge">configuration.nix</code>’s definition of <code class="language-plaintext highlighter-rouge">johndoe.shell = pkgs.zsh</code> will
take priority, despite it not being the “last” merged. In actuality,
NixOS builds the configuration as a whole without any notion of
ordering, and will fail loudly if it gets two property values with
equal priority.</p>

<p>Notice above that the NixOS configuration includes option values that
range from plain strings (e.g. <code class="language-plaintext highlighter-rouge">time.timeZone</code>) to more complex
<code class="language-plaintext highlighter-rouge">services</code> that wire up nontrivial operations (schedule daemons to
auto start, create systemd services, modprobe kernel modules,
etc.). Unlike nixpkgs, NixOS doesn’t try to specify all these
configuration options in a giant flat file; rather, it splits options
into <a href="https://nixos.wiki/wiki/NixOS_Modules">modules</a> which keep options grouped into logical
units. Modules let you create new options easily, as well at attach a
meaning to each option by doing things such as configuring other
module’s options, composing other modules together, writing files
(also done through options, interestingly), and assorted other
activities.</p>

<p>To introduce new options that vary among my work VMs and my personal
laptop, I’ve written a <a href="https://github.com/malloc47/config/blob/95eafec8373d9da302c5778964d4ce6e9c67ed22/modules/settings.nix">custom NixOS module</a>, which looks like</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nv">config</span><span class="p">,</span> <span class="nv">pkgs</span><span class="p">,</span> <span class="nv">lib</span><span class="p">,</span> <span class="o">...</span><span class="p">}:</span>

<span class="kn">with</span> <span class="nv">lib</span><span class="p">;</span>

<span class="p">{</span>
  <span class="nv">options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nv">settings</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nv">username</span> <span class="o">=</span> <span class="nv">mkOption</span> <span class="p">{</span>
        <span class="nv">default</span> <span class="o">=</span> <span class="s2">"malloc47"</span><span class="p">;</span>
        <span class="nv">type</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">types</span><span class="p">;</span> <span class="nv">uniq</span> <span class="nv">string</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nv">email</span> <span class="o">=</span> <span class="nv">mkOption</span> <span class="p">{</span>
        <span class="nv">default</span> <span class="o">=</span> <span class="s2">"malloc47@gmail.com"</span><span class="p">;</span>
        <span class="nv">type</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">types</span><span class="p">;</span> <span class="nv">uniq</span> <span class="nv">string</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="c"># more options</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This module lets me set a username for the machine being built, the
keyboard layout I want to use, the email I want to use (for my git
configuration), and many other options. I’ve written this module as a
container of values for other modules to read, but takes no action
itself (this is a trick so I can re-use the module for home-manger,
discussed below).  However, upon importing this module elsewhere, I
can set or retrieve values for these options to parameterize the rest
of my configuration. E.g.,</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">users</span><span class="o">.</span><span class="nv">users</span><span class="o">.</span><span class="p">${</span><span class="nv">config</span><span class="o">.</span><span class="nv">settings</span><span class="o">.</span><span class="nv">username</span><span class="p">}</span><span class="o">.</span><span class="nv">shell</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">zsh</span><span class="p">;</span>
</code></pre></div></div>

<p>NixOS helpfully keeps a <a href="https://nixos.org/nixos/manual/options.html">large index</a> of all options across all
modules defined in the base NixOS system, which is also available in
<code class="language-plaintext highlighter-rouge">man</code> page form on an installed system:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> man configuration.nix
</code></pre></div></div>

<p>To utilize this declarative system configuration, NixOS provides the
<code class="language-plaintext highlighter-rouge">nixos-rebuild</code> command which reads the <code class="language-plaintext highlighter-rouge">configuration.nix</code> file to
find out what nixpkgs packages it requests, templates configuration
files with the option values given, and eventually builds the entire
file tree (as usual, symlinked back to the Nix store). NixOS persists
every rebuild of your system as a sequentially numbered “generation,”
which makes it easy to examine or roll back your entire system’s
configuration to a prior state. These generations are listed in the
bootloader, so if you break something in your most recent generation,
you can boot into a prior generation to find out what went wrong.</p>

<h1 id="home-manager">home-manager</h1>

<p>I’ve traditionally versioned my home folder’s dotfiles in a git repo
and deployed it with a <a href="/git-dotfile-versioning-across-systems">hand-rolled
script</a>. Using a lightweight
window manager (formerly XMonad) means that significant portions of my
UI configuration live in my dotfiles, and this has led to increasingly
awkward workarounds to make this configuration portable across the
different hosts I regularly use. One example is controlling the Linux
HiDPI settings which are, to put it mildly, <a href="https://wiki.archlinux.org/index.php/HiDPI">a mess</a>. I specify a
slew of font tweaks, scaling factors, and DPI settings among half a
dozen dotfiles. This makes it difficult to port my dotfiles from one
machine to another.</p>

<p>The formal Nix ecosystem doesn’t (<a href="https://github.com/NixOS/nixpkgs/pull/9250">yet</a>) have a systematic
approach for writing files directly to a home folder. It <em>can</em> place
arbitrary files in an <code class="language-plaintext highlighter-rouge">/etc</code> folder. If you’re the sole user of your
machine and the application you want to configure looks at an <code class="language-plaintext highlighter-rouge">/etc</code>
directory, you could have NixOS write your dotfiles there and forego
keeping them in your home folder at all. My use case unfortunately
doesn’t fit neatly into these constraints; I have enough
home-folder-only applications that an <code class="language-plaintext highlighter-rouge">/etc</code>-based approach isn’t
viable.</p>

<p>The most Nix-native experience I’ve found for managing dotfiles is
<a href="https://github.com/rycee/home-manager">home-manager</a>. It is not only written and managed via the Nix
Expression Language, but it follows the same philosophy as the rest of
NixOS. This includes a similar approach for splitting configuration
into modules and, in fact, it supports importing my custom module
mentioned above. Though home-manager can be run with a separate
<code class="language-plaintext highlighter-rouge">home.nix</code> file and a <code class="language-plaintext highlighter-rouge">home-manager</code> CLI utility to trigger “rebuilds”
of your home folder, it additionally exposes a <a href="https://github.com/rycee/home-manager/pull/97">NixOS module</a> that
can be used in a system-level <code class="language-plaintext highlighter-rouge">configuration.nix</code> file to rebuild your
home folder following a system-wide rebuild. Being the sole user of my
systems, having NixOS and home-manager work in lockstep is preferable
for me.</p>

<p>home-manager encompasses more than just copying dotfiles to your home
folder. Some broad use cases include:</p>
<ul>
  <li>Installing packages locally for your user</li>
  <li>Placing dotfiles in your home folder</li>
  <li>Generating dotfiles from a declarative configuration</li>
  <li>Creating per-user systemd services (I use this for <code class="language-plaintext highlighter-rouge">emacs --daemon</code>,
and it is quite handy).</li>
</ul>

<p>It does all this by building a single package, <code class="language-plaintext highlighter-rouge">home-manager-path</code>,
that includes all the configured local packages and dotfiles. It then
installs this package into your local Nix environment (traditionally
managed by <code class="language-plaintext highlighter-rouge">nix-env</code>). Similar to how the rest of Nix works, each
dotfile is symlinked into your home folder from the
<code class="language-plaintext highlighter-rouge">home-manager-path</code> package contained in the Nix store. This works
similarly to how my old, hacky script managed my dotfiles.</p>

<p>The choice between having home-manager generate your dotfiles
whole-cloth, or writing your dotfiles by hand is entirely up to
you. If you’re like me and have pre-written dotfiles sitting around,
it’s easy to re-use these by</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">home</span><span class="o">.</span><span class="nv">file</span><span class="o">.</span><span class="s2">".inputrc"</span><span class="o">.</span><span class="nv">source</span> <span class="o">=</span> <span class="sx">./.inputrc</span><span class="p">;</span>
</code></pre></div></div>

<p>which insures that the <code class="language-plaintext highlighter-rouge">.inputrc</code> file in the same folder as the
<code class="language-plaintext highlighter-rouge">home.nix</code> file is deployed to <code class="language-plaintext highlighter-rouge">~/.inputrc</code> in your home
folder. home-manager supports more complex parameters–my emacs
configuration has too many files to enumerate explicitly, and
home-manager can symlink the entire directory to my home folder,
creating nested directories as necessary:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">home</span><span class="o">.</span><span class="nv">file</span><span class="o">.</span><span class="s2">".emacs.d"</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nv">source</span> <span class="o">=</span> <span class="sx">./.emacs.d</span><span class="p">;</span>
  <span class="nv">recursive</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>home-manager lets me specify file contents directly inside of
<code class="language-plaintext highlighter-rouge">home.nix</code>, which is useful if I want to reference options defined in
the aforementioned custom module:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">home</span><span class="o">.</span><span class="nv">file</span><span class="o">.</span><span class="s2">"fonts.el"</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nv">target</span> <span class="o">=</span> <span class="s2">".emacs.d/config/fonts.el"</span><span class="p">;</span>
  <span class="nv">text</span> <span class="o">=</span> <span class="s2">''</span><span class="err">
</span><span class="s2">    (provide 'fonts)</span><span class="err">
</span><span class="s2">    (set-frame-font "</span><span class="si">${</span><span class="nv">config</span><span class="o">.</span><span class="nv">settings</span><span class="o">.</span><span class="nv">fontName</span><span class="si">}</span><span class="s2">-</span><span class="si">${</span><span class="kr">toString</span> <span class="nv">config</span><span class="o">.</span><span class="nv">settings</span><span class="o">.</span><span class="nv">fontSize</span><span class="si">}</span><span class="s2">")</span><span class="err">
</span><span class="s2">    (setq default-frame-alist '((font . "</span><span class="si">${</span><span class="nv">config</span><span class="o">.</span><span class="nv">settings</span><span class="o">.</span><span class="nv">fontName</span><span class="si">}</span><span class="s2">-</span><span class="si">${</span><span class="kr">toString</span> <span class="nv">config</span><span class="o">.</span><span class="nv">settings</span><span class="o">.</span><span class="nv">fontSize</span><span class="si">}</span><span class="s2">")))</span><span class="err">
</span><span class="s2">  ''</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Since I’ve never had an extensive <code class="language-plaintext highlighter-rouge">.tmux.conf</code> file, I can use
home-manger to generate it for me:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">programs</span><span class="o">.</span><span class="nv">tmux</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nv">enable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nv">terminal</span> <span class="o">=</span> <span class="s2">"tmux-256color"</span><span class="p">;</span>
  <span class="nv">shortcut</span> <span class="o">=</span> <span class="s2">"u"</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>which creates a <code class="language-plaintext highlighter-rouge">~/.tmux.conf</code> file with (among other contents):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set  -g default-terminal "tmux-256color"

# rebind main key: C-u
unbind C-b
set -g prefix C-u
bind u send-prefix
bind C-u last-window
</code></pre></div></div>

<p>The ability to have disparate applications with varied configuration
languages wrapped by a single, type safe, functional meta-language is
cool. If the idea of writing Nix code to generate your dotfiles is too
weird, you can always fall back to having it symlink your hand-rolled
dotfiles. If you prefer a hybrid, most home-manager modules have an
<code class="language-plaintext highlighter-rouge">extra</code> option (or similar) to interleave arbitrary configuration in
the dotfiles it generates.</p>

<h1 id="layout">Layout</h1>

<p>My newly restructured <a href="https://github.com/malloc47/config">config repo</a> is now laid out with the
following directories:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/nixos/configuration.nix</code> : general OS configuration that applies
to all hosts
    <ul>
      <li>Imports <code class="language-plaintext highlighter-rouge">home.nix</code> to build my home folder</li>
      <li>Imports overlays from <code class="language-plaintext highlighter-rouge">pkgs/</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">hosts/</code> : host specific configuration:
    <ul>
      <li>Imports hardware configuration from <code class="language-plaintext highlighter-rouge">hardware/</code></li>
      <li>Imports general NixOS configuration from <code class="language-plaintext highlighter-rouge">nixos/</code></li>
      <li>Imports custom modules from <code class="language-plaintext highlighter-rouge">modules/</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">hardware/</code> : low-level configuration (file systems, kernel modules,
etc.) for use by individual hosts</li>
  <li><code class="language-plaintext highlighter-rouge">config/home.nix</code> + dotfiles
    <ul>
      <li>Imports keyboard layout from <code class="language-plaintext highlighter-rouge">xkb/</code></li>
      <li>Imports custom modules from <code class="language-plaintext highlighter-rouge">modules/</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">modules/</code> : my custom configuration module, and any future modules</li>
  <li><code class="language-plaintext highlighter-rouge">personal/</code> : private git submodule for non-public dotfiles</li>
  <li><code class="language-plaintext highlighter-rouge">pkgs/</code> : overlays for custom packages</li>
  <li><code class="language-plaintext highlighter-rouge">xkb/</code> : keyboard layouts</li>
</ul>

<p>To bootstrap a new host after doing a vanilla install of NixOS, I need
to:</p>
<ol>
  <li>Generate the appropriate <code class="language-plaintext highlighter-rouge">hardware/</code> file (or re-use an existing
one if the hardware matches).</li>
  <li>Customize a new <code class="language-plaintext highlighter-rouge">host/</code> file, including the options defined in
<code class="language-plaintext highlighter-rouge">modules/settings.nix</code> to match the needs of the new machine
(e.g. set a work email or change the default font size for HiDPI
screens).</li>
  <li>Following this, I generally symlink the <code class="language-plaintext highlighter-rouge">host/&lt;hostname&gt;.nix</code> file
to <code class="language-plaintext highlighter-rouge">/etc/nixos/configuration.nix</code> so that NixOS rebuilds don’t have
to be passed the file explicitly.</li>
  <li>Finally, running <code class="language-plaintext highlighter-rouge">nixos-rebuild</code> will construct the complete OS and
my home folder with the exact set of packages and dotfiles I’ve
defined for all of my machines.</li>
</ol>

<p>Alternatively, I could inject the configuration into the machine prior
to doing a NixOS install or even build a custom NixOS ISO that
includes my configuration in the image. Since bootstrapping my
configuration is only something I’ve had to do once per platform, I
haven’t been compelled to optimize further yet.</p>

<h1 id="conclusion">Conclusion</h1>

<p>So far I’ve been happy with my NixOS setup; I do miss the ease of the
<a href="https://aur.archlinux.org/">AUR</a> and the extensively documented <a href="https://wiki.archlinux.org/">ArchWiki</a>. Perhaps the
most important change I’ve noticed is how much bolder I can be with
toying on bare hardware; the few times I’ve messed up my system, I
just boot back into the previous generation.</p>





		</section>
	</div>
</body>

</html>